{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"csi-gcs An easy-to-use, cross-platform, and highly optimized Kubernetes CSI driver for mounting Google Cloud Storage buckets. License \u00b6 csi-gcs is distributed under the terms of both Apache License, Version 2.0 MIT License at your option. Navigation \u00b6 Desktop readers can use keyboard shortcuts to navigate. Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Home"},{"location":"#license","text":"csi-gcs is distributed under the terms of both Apache License, Version 2.0 MIT License at your option.","title":"License"},{"location":"#navigation","text":"Desktop readers can use keyboard shortcuts to navigate. Keys Action , (comma) p Navigate to the \"previous\" page . (period) n Navigate to the \"next\" page / s Display the search modal","title":"Navigation"},{"location":"dynamic_provisioning/","text":"Dynamic provisioning Secrets \u00b6 After acquiring service account keys , create 2 secrets (we'll call them csi-gcs-secret-mounter and csi-gcs-secret-creator in the following example): kubectl create secret generic csi-gcs-secret-mounter --from-file=key=<PATH_TO_SERVICE_ACCOUNT_KEY_1> kubectl create secret generic csi-gcs-secret-creator --from-file=key=<PATH_TO_SERVICE_ACCOUNT_KEY_2> --from-literal=projectId=csi-gcs Usage \u00b6 Let's run another example application! kubectl apply -k \"github.com/ofek/csi-gcs/examples/dynamic?ref=master\" Confirm it's working by running kubectl get pods,pv,pvc You should see something like NAME READY STATUS RESTARTS AGE pod/csi-gcs-test-68dbf75685-p7x4g 2/2 Running 0 11s NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE persistentvolume/pvc-3cd15760-b893-40c8-93d4-c93b121c7400 5Gi RWO Retain Bound default/csi-gcs-pvc csi-gcs 10s NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE persistentvolumeclaim/csi-gcs-pvc Bound pvc-3cd15760-b893-40c8-93d4-c93b121c7400 5Gi RWO csi-gcs 11s Note the pod name, in this case csi-gcs-test-68dbf75685-p7x4g . The pod in the example deployment has 2 containers: a writer and a reader . Now create some data! kubectl exec csi-gcs-test-68dbf75685-p7x4g -c writer -- /bin/sh -c \"echo Hello from Google Cloud Storage! > /data/test.txt\" Let's read what we just put in the bucket $ kubectl exec csi-gcs-test-68dbf75685-p7x4g -c reader -it -- /bin/sh / # ls -lh /data total 1K -rw-r--r-- 1 root root 33 Apr 19 16:18 test.txt / # cat /data/test.txt Hello from Google Cloud Storage! Notice that while the writer container's permission is completely governed by the mounter 's service account key, the reader container is further restricted to read-only access / # touch /data/forbidden.txt touch: /data/forbidden.txt: Read-only file system To clean up everything, run the following commands kubectl delete -f \"https://github.com/ofek/csi-gcs/blob/master/examples/dynamic/deployment.yaml\" kubectl delete -f \"https://github.com/ofek/csi-gcs/blob/master/examples/dynamic/pvc.yaml\" kubectl delete -f \"https://github.com/ofek/csi-gcs/blob/master/examples/dynamic/sc.yaml\" kubectl delete secret csi-gcs-secret-creator kubectl delete secret csi-gcs-secret-mounter kubectl delete -k \"github.com/ofek/csi-gcs/deploy/overlays/stable?ref=master\" Note Cleanup is necessarily verbose until this is resolved. Driver options \u00b6 StorageClass is the resource type that enables dynamic provisioning. apiVersion : storage.k8s.io/v1 kind : StorageClass metadata : name : <STORAGE_CLASS_NAME> provisioner : gcs.csi.ofek.dev reclaimPolicy : Delete parameters : ... Parameters \u00b6 Annotation Description csi.storage.k8s.io/node-publish-secret-name The name of the secret allowed to mount created buckets csi.storage.k8s.io/node-publish-secret-namespace The namespace of the secret allowed to mount created buckets csi.storage.k8s.io/provisioner-secret-name The name of the secret allowed to create buckets csi.storage.k8s.io/provisioner-secret-namespace The namespace of the secret allowed to create buckets gcs.csi.ofek.dev/project-id The project to create the buckets in. If not specified, projectId will be looked up in the provisioner's secret gcs.csi.ofek.dev/location The location to create buckets at (default US multi-region) Persistent buckets \u00b6 In our example, the dynamically created buckets are deleted during cleanup. If you want the buckets to not be ephemeral, you can set reclaimPolicy to Retain . Permission \u00b6 In order to access anything stored in GCS , you will need service accounts with appropriate IAM roles. The easiest way to create service account keys, if you don't yet have any, is to run: gcloud iam service-accounts list to find the email of a desired service account, then run: gcloud iam service-accounts keys create <FILE_NAME>.json --iam-account <EMAIL> to create a key file. Mounter \u00b6 The Node Plugin is the component that is actually mounting and serving buckets to pods. If writes are needed, you will usually select roles/storage.objectAdmin scoped to the desired buckets. Creator \u00b6 The Controller Plugin is the component that is in charge of creating buckets. The service account will need the storage.buckets.create Cloud IAM permission .","title":"Dynamic provisioning"},{"location":"dynamic_provisioning/#secrets","text":"After acquiring service account keys , create 2 secrets (we'll call them csi-gcs-secret-mounter and csi-gcs-secret-creator in the following example): kubectl create secret generic csi-gcs-secret-mounter --from-file=key=<PATH_TO_SERVICE_ACCOUNT_KEY_1> kubectl create secret generic csi-gcs-secret-creator --from-file=key=<PATH_TO_SERVICE_ACCOUNT_KEY_2> --from-literal=projectId=csi-gcs","title":"Secrets"},{"location":"dynamic_provisioning/#usage","text":"Let's run another example application! kubectl apply -k \"github.com/ofek/csi-gcs/examples/dynamic?ref=master\" Confirm it's working by running kubectl get pods,pv,pvc You should see something like NAME READY STATUS RESTARTS AGE pod/csi-gcs-test-68dbf75685-p7x4g 2/2 Running 0 11s NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE persistentvolume/pvc-3cd15760-b893-40c8-93d4-c93b121c7400 5Gi RWO Retain Bound default/csi-gcs-pvc csi-gcs 10s NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE persistentvolumeclaim/csi-gcs-pvc Bound pvc-3cd15760-b893-40c8-93d4-c93b121c7400 5Gi RWO csi-gcs 11s Note the pod name, in this case csi-gcs-test-68dbf75685-p7x4g . The pod in the example deployment has 2 containers: a writer and a reader . Now create some data! kubectl exec csi-gcs-test-68dbf75685-p7x4g -c writer -- /bin/sh -c \"echo Hello from Google Cloud Storage! > /data/test.txt\" Let's read what we just put in the bucket $ kubectl exec csi-gcs-test-68dbf75685-p7x4g -c reader -it -- /bin/sh / # ls -lh /data total 1K -rw-r--r-- 1 root root 33 Apr 19 16:18 test.txt / # cat /data/test.txt Hello from Google Cloud Storage! Notice that while the writer container's permission is completely governed by the mounter 's service account key, the reader container is further restricted to read-only access / # touch /data/forbidden.txt touch: /data/forbidden.txt: Read-only file system To clean up everything, run the following commands kubectl delete -f \"https://github.com/ofek/csi-gcs/blob/master/examples/dynamic/deployment.yaml\" kubectl delete -f \"https://github.com/ofek/csi-gcs/blob/master/examples/dynamic/pvc.yaml\" kubectl delete -f \"https://github.com/ofek/csi-gcs/blob/master/examples/dynamic/sc.yaml\" kubectl delete secret csi-gcs-secret-creator kubectl delete secret csi-gcs-secret-mounter kubectl delete -k \"github.com/ofek/csi-gcs/deploy/overlays/stable?ref=master\" Note Cleanup is necessarily verbose until this is resolved.","title":"Usage"},{"location":"dynamic_provisioning/#driver-options","text":"StorageClass is the resource type that enables dynamic provisioning. apiVersion : storage.k8s.io/v1 kind : StorageClass metadata : name : <STORAGE_CLASS_NAME> provisioner : gcs.csi.ofek.dev reclaimPolicy : Delete parameters : ...","title":"Driver options"},{"location":"dynamic_provisioning/#parameters","text":"Annotation Description csi.storage.k8s.io/node-publish-secret-name The name of the secret allowed to mount created buckets csi.storage.k8s.io/node-publish-secret-namespace The namespace of the secret allowed to mount created buckets csi.storage.k8s.io/provisioner-secret-name The name of the secret allowed to create buckets csi.storage.k8s.io/provisioner-secret-namespace The namespace of the secret allowed to create buckets gcs.csi.ofek.dev/project-id The project to create the buckets in. If not specified, projectId will be looked up in the provisioner's secret gcs.csi.ofek.dev/location The location to create buckets at (default US multi-region)","title":"Parameters"},{"location":"dynamic_provisioning/#persistent-buckets","text":"In our example, the dynamically created buckets are deleted during cleanup. If you want the buckets to not be ephemeral, you can set reclaimPolicy to Retain .","title":"Persistent buckets"},{"location":"dynamic_provisioning/#permission","text":"In order to access anything stored in GCS , you will need service accounts with appropriate IAM roles. The easiest way to create service account keys, if you don't yet have any, is to run: gcloud iam service-accounts list to find the email of a desired service account, then run: gcloud iam service-accounts keys create <FILE_NAME>.json --iam-account <EMAIL> to create a key file.","title":"Permission"},{"location":"dynamic_provisioning/#mounter","text":"The Node Plugin is the component that is actually mounting and serving buckets to pods. If writes are needed, you will usually select roles/storage.objectAdmin scoped to the desired buckets.","title":"Mounter"},{"location":"dynamic_provisioning/#creator","text":"The Controller Plugin is the component that is in charge of creating buckets. The service account will need the storage.buckets.create Cloud IAM permission .","title":"Creator"},{"location":"getting_started/","text":"Getting started Installation \u00b6 Like other CSI drivers, a StatefulSet and DaemonSet are the recommended deployment mechanisms for the Controller Plugin and Node Plugin , respectively. Run kubectl apply -k \"github.com/ofek/csi-gcs/deploy/overlays/stable?ref=master\" Now the output from running the command kubectl get CSIDriver,daemonsets,statefulsets,pods -n kube-system should contain something like NAME CREATED AT csidriver.storage.k8s.io/gcs.csi.ofek.dev 2020-04-19T03:35:52Z NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.extensions/csi-gcs-node 1 1 1 1 1 <none> 4s NAME READY AGE statefulset.apps/csi-gcs-controller 1/1 4s NAME READY STATUS RESTARTS AGE pod/csi-gcs-controller-0 2/2 Running 0 4s pod/csi-gcs-node-mbmnc 2/2 Running 0 4s Debugging \u00b6 kubectl logs -l app=csi-gcs-controller -c csi-gcs-controller -n kube-system kubectl logs -l app=csi-gcs-node -c csi-gcs-node -n kube-system","title":"Getting started"},{"location":"getting_started/#installation","text":"Like other CSI drivers, a StatefulSet and DaemonSet are the recommended deployment mechanisms for the Controller Plugin and Node Plugin , respectively. Run kubectl apply -k \"github.com/ofek/csi-gcs/deploy/overlays/stable?ref=master\" Now the output from running the command kubectl get CSIDriver,daemonsets,statefulsets,pods -n kube-system should contain something like NAME CREATED AT csidriver.storage.k8s.io/gcs.csi.ofek.dev 2020-04-19T03:35:52Z NAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE daemonset.extensions/csi-gcs-node 1 1 1 1 1 <none> 4s NAME READY AGE statefulset.apps/csi-gcs-controller 1/1 4s NAME READY STATUS RESTARTS AGE pod/csi-gcs-controller-0 2/2 Running 0 4s pod/csi-gcs-node-mbmnc 2/2 Running 0 4s","title":"Installation"},{"location":"getting_started/#debugging","text":"kubectl logs -l app=csi-gcs-controller -c csi-gcs-controller -n kube-system kubectl logs -l app=csi-gcs-node -c csi-gcs-node -n kube-system","title":"Debugging"},{"location":"static_provisioning/","text":"Static provisioning Secrets \u00b6 After acquiring a service account key , create a secret (we'll call it csi-gcs-secret in the following example): kubectl create secret generic csi-gcs-secret --from-literal=bucket=<BUCKET_NAME> --from-file=key=<PATH_TO_SERVICE_ACCOUNT_KEY> Note we store the desired bucket in the secret for brevity only, there are other ways to select a bucket. Usage \u00b6 Let's run an example application! kubectl apply -k \"github.com/ofek/csi-gcs/examples/static?ref=master\" Confirm it's working by running kubectl get pods,pv,pvc You should see something like NAME READY STATUS RESTARTS AGE pod/csi-gcs-test-cbc546b4-5kb7h 2/2 Running 0 1m40s NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE persistentvolume/csi-gcs-pv 5Gi RWO Retain Bound default/csi-gcs-pvc csi-gcs-test-sc 1m40s NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE persistentvolumeclaim/csi-gcs-pvc Bound csi-gcs-pv 5Gi RWO csi-gcs-test-sc 1m40s Note the pod name, in this case csi-gcs-test-cbc546b4-5kb7h . The pod in the example deployment has 2 containers: a writer and a reader . Now create some data! kubectl exec csi-gcs-test-cbc546b4-5kb7h -c writer -- /bin/sh -c \"echo Hello from Google Cloud Storage! > /data/test.txt\" Let's read what we just put in the bucket $ kubectl exec csi-gcs-test-cbc546b4-5kb7h -c reader -it -- /bin/sh / # ls -lh /data total 1K -rw-r--r-- 1 root root 33 Jan 26 17:55 test.txt / # cat /data/test.txt Hello from Google Cloud Storage! Notice that while the writer container's permission is completely governed by the service account key, the reader container is further restricted to read-only access / # touch /data/forbidden.txt touch: /data/forbidden.txt: Read-only file system To clean up everything, run the following commands kubectl delete -k \"github.com/ofek/csi-gcs/examples/static?ref=master\" kubectl delete secret csi-gcs-secret kubectl delete -k \"github.com/ofek/csi-gcs/deploy/overlays/stable?ref=master\" Driver options \u00b6 See the CSI section of the Kubernetes Volume docs . Service account key \u00b6 The contents of the JSON key may be passed in as a secret defined in nodePublishSecretRef . The name of the key is key Bucket \u00b6 The bucket name is resolved in the following order: bucket in volumeAttributes bucket in secret referenced by nodePublishSecretRef volumeHandle Extra flags \u00b6 You can pass arbitrary flags to gcsfuse by setting flags in volumeAttributes e.g. --limit-ops-per-sec=10 --only-dir=some/nested/folder . Permission \u00b6 In order to access anything stored in GCS , you will need service accounts with appropriate IAM roles. If writes are needed, you will usually select roles/storage.objectAdmin scoped to the desired buckets. The easiest way to create service account keys, if you don't yet have any, is to run: gcloud iam service-accounts list to find the email of a desired service account, then run: gcloud iam service-accounts keys create <FILE_NAME>.json --iam-account <EMAIL> to create a key file.","title":"Static provisioning"},{"location":"static_provisioning/#secrets","text":"After acquiring a service account key , create a secret (we'll call it csi-gcs-secret in the following example): kubectl create secret generic csi-gcs-secret --from-literal=bucket=<BUCKET_NAME> --from-file=key=<PATH_TO_SERVICE_ACCOUNT_KEY> Note we store the desired bucket in the secret for brevity only, there are other ways to select a bucket.","title":"Secrets"},{"location":"static_provisioning/#usage","text":"Let's run an example application! kubectl apply -k \"github.com/ofek/csi-gcs/examples/static?ref=master\" Confirm it's working by running kubectl get pods,pv,pvc You should see something like NAME READY STATUS RESTARTS AGE pod/csi-gcs-test-cbc546b4-5kb7h 2/2 Running 0 1m40s NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE persistentvolume/csi-gcs-pv 5Gi RWO Retain Bound default/csi-gcs-pvc csi-gcs-test-sc 1m40s NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE persistentvolumeclaim/csi-gcs-pvc Bound csi-gcs-pv 5Gi RWO csi-gcs-test-sc 1m40s Note the pod name, in this case csi-gcs-test-cbc546b4-5kb7h . The pod in the example deployment has 2 containers: a writer and a reader . Now create some data! kubectl exec csi-gcs-test-cbc546b4-5kb7h -c writer -- /bin/sh -c \"echo Hello from Google Cloud Storage! > /data/test.txt\" Let's read what we just put in the bucket $ kubectl exec csi-gcs-test-cbc546b4-5kb7h -c reader -it -- /bin/sh / # ls -lh /data total 1K -rw-r--r-- 1 root root 33 Jan 26 17:55 test.txt / # cat /data/test.txt Hello from Google Cloud Storage! Notice that while the writer container's permission is completely governed by the service account key, the reader container is further restricted to read-only access / # touch /data/forbidden.txt touch: /data/forbidden.txt: Read-only file system To clean up everything, run the following commands kubectl delete -k \"github.com/ofek/csi-gcs/examples/static?ref=master\" kubectl delete secret csi-gcs-secret kubectl delete -k \"github.com/ofek/csi-gcs/deploy/overlays/stable?ref=master\"","title":"Usage"},{"location":"static_provisioning/#driver-options","text":"See the CSI section of the Kubernetes Volume docs .","title":"Driver options"},{"location":"static_provisioning/#service-account-key","text":"The contents of the JSON key may be passed in as a secret defined in nodePublishSecretRef . The name of the key is key","title":"Service account key"},{"location":"static_provisioning/#bucket","text":"The bucket name is resolved in the following order: bucket in volumeAttributes bucket in secret referenced by nodePublishSecretRef volumeHandle","title":"Bucket"},{"location":"static_provisioning/#extra-flags","text":"You can pass arbitrary flags to gcsfuse by setting flags in volumeAttributes e.g. --limit-ops-per-sec=10 --only-dir=some/nested/folder .","title":"Extra flags"},{"location":"static_provisioning/#permission","text":"In order to access anything stored in GCS , you will need service accounts with appropriate IAM roles. If writes are needed, you will usually select roles/storage.objectAdmin scoped to the desired buckets. The easiest way to create service account keys, if you don't yet have any, is to run: gcloud iam service-accounts list to find the email of a desired service account, then run: gcloud iam service-accounts keys create <FILE_NAME>.json --iam-account <EMAIL> to create a key file.","title":"Permission"},{"location":"contributing/authors/","text":"Authors Maintainers \u00b6 Ofek Lev ( @ofek ) Contributors \u00b6 Jonatan M\u00e4nnchen ( @maennchen )","title":"Authors"},{"location":"contributing/authors/#maintainers","text":"Ofek Lev ( @ofek )","title":"Maintainers"},{"location":"contributing/authors/#contributors","text":"Jonatan M\u00e4nnchen ( @maennchen )","title":"Contributors"},{"location":"contributing/setup/","text":"Setup Getting started \u00b6 Dependencies You'll need to have Python 3.6+ in your PATH python -m pip install --upgrade -r requirements.txt Minikube Setup minikube Start minikube ( minikube start ) Build Enable minikube Docker Env ( eval $(minikube docker-env) ) Build Docker Image invoke image gcloud Install gcloud Login to gcloud ( gcloud auth login ) Google Cloud Project Create Test Project ( gcloud projects create [PROJECT_ID] --name=[PROJECT_NAME] ) Google Cloud Service Account Create ( gcloud iam service-accounts create [ACCOUNT_NAME] --display-name=\"Test Account\" --description=\"Test Account for GCS CSI\" --project=[PROJECT_ID] ) Create Key ( gcloud iam service-accounts keys create service-account.json --iam-account=[ACCOUNT_NAME]@[PROJECT_ID].iam.gserviceaccount.com --project=[PROJECT_ID] ) Give Storage Admin Permission ( gcloud projects add-iam-policy-binding [ACCOUNT_NAME] --member=serviceAccount:[ACCOUNT_NAME]@[PROJECT_ID].iam.gserviceaccount.com --role=roles/storage.admin ) Create Secret kubectl create secret generic csi-gcs-secret --from-file=key=service-account.json Pull Needed Images docker pull quay.io/k8scsi/csi-node-driver-registrar:v1.2.0 Apply config kubectl apply -k deploy/overlays/dev Rebuild & Test \u00b6 Build Docker Image invoke image Delete Pod Build docs \u00b6 invoke docs","title":"Setup"},{"location":"contributing/setup/#getting-started","text":"Dependencies You'll need to have Python 3.6+ in your PATH python -m pip install --upgrade -r requirements.txt Minikube Setup minikube Start minikube ( minikube start ) Build Enable minikube Docker Env ( eval $(minikube docker-env) ) Build Docker Image invoke image gcloud Install gcloud Login to gcloud ( gcloud auth login ) Google Cloud Project Create Test Project ( gcloud projects create [PROJECT_ID] --name=[PROJECT_NAME] ) Google Cloud Service Account Create ( gcloud iam service-accounts create [ACCOUNT_NAME] --display-name=\"Test Account\" --description=\"Test Account for GCS CSI\" --project=[PROJECT_ID] ) Create Key ( gcloud iam service-accounts keys create service-account.json --iam-account=[ACCOUNT_NAME]@[PROJECT_ID].iam.gserviceaccount.com --project=[PROJECT_ID] ) Give Storage Admin Permission ( gcloud projects add-iam-policy-binding [ACCOUNT_NAME] --member=serviceAccount:[ACCOUNT_NAME]@[PROJECT_ID].iam.gserviceaccount.com --role=roles/storage.admin ) Create Secret kubectl create secret generic csi-gcs-secret --from-file=key=service-account.json Pull Needed Images docker pull quay.io/k8scsi/csi-node-driver-registrar:v1.2.0 Apply config kubectl apply -k deploy/overlays/dev","title":"Getting started"},{"location":"contributing/setup/#rebuild-test","text":"Build Docker Image invoke image Delete Pod","title":"Rebuild &amp; Test"},{"location":"contributing/setup/#build-docs","text":"invoke docs","title":"Build docs"}]}